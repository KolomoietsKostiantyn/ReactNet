# Название workflow'а, как он будет отображаться в GitHub Actions
name: Build and deploy ASP.NET Core app to Azure Web App - app-reactivities-api-dev

on:
  push:
    branches: [ main ]     # триггер: любой push в main запускает только build+test
  workflow_dispatch:        # ручной запуск; при нем выполнится и деплой

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read        # нужно, чтобы checkout мог читать репозиторий

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        # ↓ Клонируем код репозитория

      - name: Set up .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.x'
        # ↓ Ставим SDK .NET 8.x, чтобы можно было билдить/тестировать

      - name: Restore
        run: dotnet restore
        working-directory: ./Reactivities
        # ↓ Качаем NuGet-пакеты для решения/проекта в папке Reactivities

      - name: Build
        run: dotnet build --configuration Release --no-restore
        working-directory: ./Reactivities
        # ↓ Компилируем в Release (без повторного restore)

      - name: Test (auto-skip if no tests)
        shell: bash
        working-directory: ./Reactivities
        run: |
          set -e
          # Ищем любые проекты с окончанием *Test.csproj / *test.csproj
          TEST_PROJECTS=$(find . -type f -name "*[Tt]est.csproj")
          if [ -n "$TEST_PROJECTS" ]; then
            echo "Found test projects:"
            echo "$TEST_PROJECTS"
            for proj in $TEST_PROJECTS; do
              echo "Running tests in $proj"
              dotnet test "$proj" --configuration Release --no-build --logger "trx;LogFileName=$(basename "$proj").trx"
            done
          else
            echo "No *Test.csproj found. Skipping tests."
          fi
        # ↓ Ищем тестовые проекты; если есть — гоняем тесты и пишем отчёт .trx; если нет — пропускаем

      - name: Publish
        run: dotnet publish -c Release -o ${{ runner.temp }}/publish
        working-directory: ./Reactivities
        # ↓ Собираем self-contained папку приложения (артефакты для деплоя) в $RUNNER_TEMP/publish

      - name: Upload artifact for deployment
        uses: actions/upload-artifact@v4
        with:
          name: dotnet-app
          path: ${{ runner.temp }}/publish
        # ↓ Загружаем собранный publish как артефакт, чтобы job "deploy" мог его забрать

  deploy:
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'workflow_dispatch'
    # ↓ Деплой выполняется ТОЛЬКО при ручном запуске (кнопка Run workflow)

    permissions:
      id-token: write        # нужно для OIDC-логина в Azure
      contents: read

    steps:
      - name: Download artifact from build job
        uses: actions/download-artifact@v4
        with:
          name: dotnet-app
        # ↓ Скачиваем артефакт (папку publish), созданный на этапе build

      - name: Login to Azure
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZUREAPPSERVICE_CLIENTID_E2FD0734C95C453B990205A82973CAA5 }}
          tenant-id: ${{ secrets.AZUREAPPSERVICE_TENANTID_E31B8BBD953F4CD782C51E20D8F6092A }}
          subscription-id: ${{ secrets.AZUREAPPSERVICE_SUBSCRIPTIONID_1368705159CA480E94295E75B1D2E5B2 }}
        # ↓ Логинимся в Azure через OIDC (использует выданные Azure секреты)

      - name: Deploy to Azure Web App
        uses: azure/webapps-deploy@v3
        with:
          app-name: 'app-reactivities-api-dev'   # имя вашего Web App в Azure
          slot-name: 'Production'
          package: .
        # ↓ Деплоим скачанный артефакт в выбранный Web App (слот Production)
